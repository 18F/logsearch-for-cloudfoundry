##--------------------------
# App conf. Parses app logs.|
##--------------------------

if [@metadata][index] == "app" {

    mutate {
      add_tag => [ "app" ]
    }

    # Parse Cloud Foundry logs from doppler firehose (via https://github.com/SpringerPE/firehose-to-syslog)
    json {
      source => "@message"
      target => "app"
    }

    if "_jsonparsefailure" in [tags] {

        # Amend the failure tag to match our fail/${addon}/${filter}/${detail} standard
        mutate {
            add_tag => ["fail/cloudfoundry/app/json"]
            remove_tag => ["_jsonparsefailure"]
        }

    } else {

        # Rework log message.
        #
        # 1) Replace the unicode newline character \u2028 with \n, which Kibana will display as a new line.
        #    Seems that passing a string with an actual newline in it is the only way to make gsub work.
        # 2) Replace the unicode Null character \u0000 with ""
        mutate {
          gsub => [ "[app][msg]", '\u2028', "
"
          ]
          gsub => [ "[app][msg]", '\u0000', ""]
        }

        # Drop useless message log.
        if [app][msg] =~ /^\s*$/ or [app][msg] =~ /^#.*$/ {
          drop { }
        }

        # Set @message and @level
        mutate {
          rename => { "[app][msg]" => "@message" } # @message
          rename => { "[app][level]" => "@level" } # @level
        }
        
        # Set @timestamp
        ruby { # convert [app][timestamp] from nanosec-from-epoch number to Datetime
          init => "require 'time'"
          code => "time_in_nanosec_from_epoch = event['[app][timestamp]']
                     time_in_seconds = time_in_nanosec_from_epoch / 10 ** 9
                     milliseconds = time_in_nanosec_from_epoch % 10 ** 9 / 1000.to_f
                     event['[app][timestamp]'] = Time.at(time_in_seconds, milliseconds).iso8601(6)
                     "
        }
        date {
          match => [ "[app][timestamp]", "ISO8601" ] # date
        }
        mutate {
          remove_field => [ "[app][timestamp]", "[app][time]" ]
        }

        # Set @source fields
        mutate {
          rename => { "[app][cf_org_id]"     => "[@source][org_id]" }
          rename => { "[app][cf_org_name]"   => "[@source][org]" }
          rename => { "[app][cf_space_id]"   => "[@source][space_id]" }
          rename => { "[app][cf_space_name]" => "[@source][space]" }
          rename => { "[app][cf_app_id]"     => "[@source][app_id]" }
          rename => { "[app][cf_app_name]"   => "[@source][app]" }

          rename => { "[app][origin]"        => "[@source][origin]" }
          rename => { "[app][cf_origin]"     => "[@source][cf_origin]" }
          rename => { "[app][message_type]"  => "[@source][message_type]" } # OUT/ ERR

          rename => { "[app][deployment]" => "[@source][deployment]" }
          rename => { "[app][ip]" => "[@source][host]" }
          rename => { "[app][job]" => "[@source][job]" }

          rename => { "[app][source_instance]" => "[@source][instance]" }
          rename => { "[app][index]" => "[@source][index]" }

          rename => { "[app][source_type]" => "[@source][component]" }
          uppercase => [ "[@source][component]" ] # we rely on component value in next scripts so let's uppercase it

          rename => { "[app][event_type]" => "@type" }
        }

        # Override @type
        alter {
          coalesce => [ "@type", "%{@type}", "UndefinedEvent" ]
        }

        # Override @metadata.index
        if [@source][org] {
            mutate { replace => { "[@metadata][index]" => "%{[@metadata][index]}-%{[@source][org]}" } }
            if [@source][space] {
                mutate { replace => { "[@metadata][index]" => "%{[@metadata][index]}-%{[@source][space]}" } }
            }
            mutate { lowercase => [ "[@metadata][index]" ] }
        }
    }

}
