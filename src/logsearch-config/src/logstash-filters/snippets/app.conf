if [@message] =~ /.*"event_type":"AppEvent".*/ {

    # Parse messages from /v2/events api logged by https://github.com/18F/cf-app-events-logger

    json {
        source => "[@message]"
        target => "[app_event]"
        add_tag => "app_event"
    }

    date {
        match => [ "[app_event][timestamp]", "ISO8601" ]
    }

    ruby {
        code => "event['@metadata']['app_event_metadata_as_string'] = event['app_event']['metadata'].to_s"
    }
    mutate {
        replace => { "[@message]" => "%{[app_event][type]} %{[@metadata][app_event_metadata_as_string]}" }
    }

    mutate {
        replace => { "[@source][component]" => "AppEvent" }
        replace => { "[@source][instance]" => "0" }
        convert => { "[@source][instance]" => "integer" }
        replace => { "[@source][name]" => "AppEvent/0" }

        replace => { "[@source][app][id]" => "%{[app_event][actee]}" }
        replace => { "[@source][app][name]" => "%{[app_event][events_actee_name]}" }
        replace => { "[@source][space][id]" => "%{[app_event][space_guid]}" }
        replace => { "[@source][space][name]" => "%{[app_event][events_space_name]}" }
        replace => { "[@source][org][id]" => "%{[app_event][organization_guid]}" }
        replace => { "[@source][org][name]" => "%{[app_event][events_org_name]}" }

        replace => { "[@metadata][type]" => "app_event" }

        remove_field => [ "[@source][message_type]", "[@source][origin]", "[@source][host]" ]
    }

} else if [@type] in ["syslog", "relp"] and [syslog_program] == "doppler" {

    # Parse Cloud Foundry logs from doppler firehose (via https://github.com/SpringerPE/firehose-to-syslog)

    json {
      source => "@message"
      target => "app"
    }

    if "_jsonparsefailure" in [tags] {

        # Amend the failure tag to match our fail/${addon}/${filter}/${detail} standard
        mutate {
            add_tag => ["fail/cloudfoundry/app/json"]
            remove_tag => ["_jsonparsefailure"]
        }

    } else {

        # -------- message additional parsing ----------
        # Replace the unicode Null character \u0000 with ""
        # Replace the unicode newline character \u2028 with \n, which Kibana will display as a new line.  Seems that passing a string with an actual newline in it is the only way to make gsub work
        mutate {
          gsub => [ "[app][msg]", '\u2028', "
"
          ]
          gsub => [ "[app][msg]", '\u0000', ""]
        }
        # Ignore logs with empty msg
        if [app][msg] =~ /^\s*$/ or [app][msg] =~ /^#.*$/ {
          drop { }
        }

        # @message and @level
        mutate {
          rename => { "[app][msg]" => "@message" } # @message
          rename => { "[app][level]" => "@level" } # @level
        }

        # @timestamp
        ruby { # convert [app][timestamp] from nanosec-from-epoch number to Datetime
            init => "require 'time'"
            code => "time_in_nanosec_from_epoch = event['[app][timestamp]']
                     time_in_seconds = time_in_nanosec_from_epoch / 10 ** 9
                     milliseconds = time_in_nanosec_from_epoch % 10 ** 9 / 1000.to_f
                     event['[app][timestamp]'] = Time.at(time_in_seconds, milliseconds).iso8601(6)
                     "
        }
        date {
            match => [ "[app][timestamp]", "ISO8601" ] # date
        }

        # ------------- app fields ------------------
        # by default all logs should have event_type LogMessage
        if ![app][event_type] {
            mutate {
              add_field => [ "[app][event_type]", "LogMessage" ]
            }
        }

        # app @source
        mutate {
          rename => { "[app][cf_org_id]"     => "[@source][org_id]" }
          rename => { "[app][cf_org_name]"   => "[@source][org]" }
          rename => { "[app][cf_space_id]"   => "[@source][space_id]" }
          rename => { "[app][cf_space_name]" => "[@source][space]" }
          rename => { "[app][cf_app_id]"     => "[@source][app_id]" }
          rename => { "[app][cf_app_name]"   => "[@source][app]" }

          rename => { "[app][origin]"        => "[@source][origin]" } # CF logging component
          rename => { "[app][message_type]"  => "[@source][message_type]" } # OUT/ ERR

          rename => { "[app][deployment]" => "[@source][deployment]" }
          rename => { "[app][ip]" => "[@source][host]" }
          rename => { "[app][job]" => "[@source][job]" }
        }

        # ------------- common fields ------------------

        # override @source.component & @source.instance
        mutate {
          rename => { "[app][source_type]" => "[@source][component]" }
          rename => { "[app][source_instance]" => "[@source][instance]" }
        }
        mutate {
          uppercase => [ "[@source][component]" ] # we rely on component value in next scripts so let's uppercase it
        }

        # override index
        mutate { replace => { "[@metadata][index]" => "app" } }
        if [@source][org] {
            mutate { replace => { "[@metadata][index]" => "%{[@metadata][index]}-%{[@source][org]}" } }
            if [@source][space] {
                mutate { replace => { "[@metadata][index]" => "%{[@metadata][index]}-%{[@source][space]}" } }
            }
            mutate { lowercase => [ "[@metadata][index]" ] }
        }

        # override @type and tags
        mutate {
          replace => { "@type" => "%{[app][event_type]}" }
          add_tag => [ "app" ]
        }

        # cleanup
        mutate {
          remove_field => "[app]"
        }
    }

}
